import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { motion } from "framer-motion";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  ResponsiveContainer,
  Tooltip,
  ReferenceLine,
} from "recharts";

const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
const toDbFS = (rms) => {
  const eps = 1e-12;
  const v = Math.max(rms, eps);
  return 20 * Math.log10(v);
};
function ema(prev, next, alpha) {
  if (prev === null) return next;
  return alpha * next + (1 - alpha) * prev;
}
const fmt1 = (n) => (Number.isFinite(n) ? n.toFixed(1) : "--");

export default function DecibelMeter() {
  const [running, setRunning] = useState(false);
  const [displayDb, setDisplayDb] = useState(null);
  const [peakDb, setPeakDb] = useState(null);
  const [calOffset, setCalOffset] = useState(0);
  const [name, setName] = useState("My Mic");
  const [holdPeak, setHoldPeak] = useState(true);
  const [smoothingMs, setSmoothingMs] = useState(250);
  const [history, setHistory] = useState([]);
  const [err, setErr] = useState("");
  const [permState, setPermState] = useState("unknown");

  const acRef = useRef(null);
  const srcRef = useRef(null);
  const analyserRef = useRef(null);
  const rafRef = useRef(null);
  const bufRef = useRef(null);
  const emaRef = useRef(null);
  const lastPeakRef = useRef(null);
  const lastPeakTsRef = useRef(0);
  const streamRef = useRef(null);

  const historyWindowSec = 15;
  const targetFps = 20;

  const stopInternal = useCallback(() => {
    try { if (rafRef.current) cancelAnimationFrame(rafRef.current); } catch {}
    rafRef.current = null;
    if (srcRef.current) srcRef.current.disconnect?.();
    if (analyserRef.current) analyserRef.current.disconnect?.();
    streamRef.current?.getTracks().forEach(t => t.stop());
    streamRef.current = null;
    acRef.current?.close?.();
    acRef.current = null;
    srcRef.current = null;
    analyserRef.current = null;
    bufRef.current = null;
    emaRef.current = null;
    lastPeakRef.current = null;
    lastPeakTsRef.current = 0;
    setRunning(false);
  }, []);

  const stop = useCallback(() => { stopInternal(); }, [stopInternal]);

  const checkPermissionState = useCallback(async () => {
    if (!('permissions' in navigator)) { setPermState('unsupported'); return 'unsupported'; }
    try {
      const s = await navigator.permissions.query({ name: 'microphone' });
      setPermState(s.state ?? 'unknown');
      return s.state ?? 'unknown';
    } catch { setPermState('error'); return 'error'; }
  }, []);

  const start = useCallback(async () => {
    if (running) return;
    if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1', ''].includes(window.location.hostname)) {
      setErr('HTTPS が必要です。');
      return;
    }
    try {
      setErr("");
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
      streamRef.current = stream;
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      if (ac.state === 'suspended') await ac.resume();
      const src = ac.createMediaStreamSource(stream);
      const analyser = ac.createAnalyser();
      analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0;
      acRef.current = ac; srcRef.current = src; analyserRef.current = analyser; src.connect(analyser);
      bufRef.current = new Float32Array(analyser.fftSize);
      emaRef.current = null; lastPeakRef.current = null; lastPeakTsRef.current = 0;
      setPeakDb(null); setDisplayDb(null); setHistory([]);

      const loop = () => {
        const analyser = analyserRef.current, ac = acRef.current, buf = bufRef.current;
        if (!analyser || !ac || !buf) return;
        if (ac.state === 'suspended' || ac.state === 'closed') { rafRef.current = requestAnimationFrame(loop); return; }
        analyser.getFloatTimeDomainData(buf);
        let sumSq = 0; for (let i = 0; i < buf.length; i++) sumSq += buf[i]*buf[i];
        const rmsInst = Math.sqrt(sumSq / buf.length);
        const dt = 1000 / targetFps; const alpha = clamp(dt / Math.max(1, smoothingMs), 0.01, 1);
        const rmsSmoothed = ema(emaRef.current, rmsInst, alpha); emaRef.current = rmsSmoothed;
        const dBFS = toDbFS(rmsSmoothed); const dB = dBFS + calOffset;
        const now = performance.now(); const decayPerSec = 6;
        if (holdPeak) {
          if (lastPeakRef.current == null || dB > lastPeakRef.current) { lastPeakRef.current = dB; lastPeakTsRef.current = now; }
          else { const dtSec = (now - lastPeakTsRef.current)/1000; lastPeakRef.current -= decayPerSec*dtSec; lastPeakTsRef.current = now; }
          setPeakDb(lastPeakRef.current);
        } else setPeakDb(dB);
        setDisplayDb(dB);
        setHistory(h => { const t = ac.currentTime; const next = [...h, { t, dB }]; const minT = t - historyWindowSec; while(next.length && next[0].t<minT) next.shift(); return next; });
        rafRef.current = requestAnimationFrame(loop);
      };
      rafRef.current = requestAnimationFrame(loop);
      setRunning(true);
    } catch (e) { setErr(e.message || 'マイクにアクセスできません'); setRunning(false); }
  }, [calOffset, holdPeak, smoothingMs, running, stopInternal]);

  useEffect(() => { return () => stop(); }, [stop]);

  const levelForBar = useMemo(() => { const dB = displayDb ?? -Infinity; return clamp((dB-20)/(100-20),0,1); }, [displayDb]);
  const historyData = useMemo(() => { const t0 = history.length? history[0].t:0; return history.map(p=>({ x: Math.max(0,p.t-t0), dB: Number.isFinite(p.dB)?Number(p.dB.toFixed(1)):null })); }, [history]);

  return (
    <div className="min-h-screen w-full bg-white text-gray-900 p-6">
      <div className="mx-auto max-w-5xl grid gap-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">ブラウザで動く デシベルメーター</h1>
          <div className="flex items-center gap-2">
            {!running ? (
              <button onClick={start} className="rounded-2xl shadow-lg bg-blue-500 text-white px-4 py-2 flex items-center gap-2"><span>🎤</span> マイク開始</button>
            ) : (
              <button onClick={stop} className="rounded-2xl shadow-lg bg-red-500 text-white px-4 py-2 flex items-center gap-2">■ 停止</button>
            )}
          </div>
        </header>
        {err && <div className="border border-red-300 bg-red-50 p-4 text-red-800 text-sm">マイクエラー: {err}</div>}
        <div className="grid md:grid-cols-3 gap-6">
          <div className="md:col-span-2 border rounded p-4">
            <div className="text-6xl font-extrabold">{displayDb==null?'--.-':fmt1(displayDb)} dB</div>
            <div className="text-3xl font-bold">ピーク: {peakDb==null?'--.-':fmt1(peakDb)} dB</div>
            <div className="mt-6 h-6 w-full rounded-2xl bg-gray-100 overflow-hidden">
              <motion.div className="h-full rounded-2xl" style={{ background: 'linear-gradient(90deg, #3b82f6 0%, #22c55e 60%, #eab308 80%, #ef4444
